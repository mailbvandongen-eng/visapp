{"version":3,"file":"GeoJSON-DKqsfh74.js","sources":["../../node_modules/ol/geom/LineString.js","../../node_modules/ol/geom/GeometryCollection.js","../../node_modules/ol/geom/MultiLineString.js","../../node_modules/ol/geom/MultiPoint.js","../../node_modules/ol/geom/MultiPolygon.js","../../node_modules/ol/format/Feature.js","../../node_modules/ol/format/JSONFeature.js","../../node_modules/ol/format/GeoJSON.js"],"sourcesContent":["/**\n * @module ol/geom/LineString\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {interpolatePoint, lineStringCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineString} from './flat/intersectsextent.js';\nimport {lineStringLength} from './flat/length.js';\nimport {forEach as forEachSegment} from './flat/segments.js';\nimport {douglasPeucker} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nclass LineString extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate|null}\n     */\n    this.flatMidpoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatMidpointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n    } else {\n      this.setCoordinates(\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    }\n  }\n\n  /**\n   * Append the passed coordinate to the coordinates of the linestring.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @api\n   */\n  appendCoordinate(coordinate) {\n    extend(this.flatCoordinates, coordinate);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LineString} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const lineString = new LineString(\n      this.flatCoordinates.slice(),\n      this.layout,\n    );\n    lineString.applyProperties(this);\n    return lineString;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        maxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.flatCoordinates.length,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      this.maxDelta_,\n      false,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * Iterate over each segment, calling the provided callback.\n   * If the callback returns a truthy value the function returns that\n   * value immediately. Otherwise the function returns `false`.\n   *\n   * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.\n   * @return {T|boolean} Value.\n   * @template T,S\n   * @api\n   */\n  forEachSegment(callback) {\n    return forEachSegment(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      callback,\n    );\n  }\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * @param {number} m M.\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n   * @api\n   */\n  getCoordinateAtM(m, extrapolate) {\n    if (this.layout != 'XYM' && this.layout != 'XYZM') {\n      return null;\n    }\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\n    return lineStringCoordinateAtM(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      m,\n      extrapolate,\n    );\n  }\n\n  /**\n   * Return the coordinates of the linestring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   * @override\n   */\n  getCoordinates() {\n    return inflateCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * Return the coordinate at the provided fraction along the linestring.\n   * The `fraction` is a number between 0 and 1, where 0 is the start of the\n   * linestring and 1 is the end.\n   * @param {number} fraction Fraction.\n   * @param {import(\"../coordinate.js\").Coordinate} [dest] Optional coordinate whose values will\n   *     be modified. If not provided, a new coordinate will be returned.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n   * @api\n   */\n  getCoordinateAt(fraction, dest) {\n    return interpolatePoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      fraction,\n      dest,\n      this.stride,\n    );\n  }\n\n  /**\n   * Return the length of the linestring on projected plane.\n   * @return {number} Length (on projected plane).\n   * @api\n   */\n  getLength() {\n    return lineStringLength(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  getFlatMidpoint() {\n    if (this.flatMidpointRevision_ != this.getRevision()) {\n      this.flatMidpoint_ = this.getCoordinateAt(\n        0.5,\n        this.flatMidpoint_ ?? undefined,\n      );\n      this.flatMidpointRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.flatMidpoint_);\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} Simplified LineString.\n   * @protected\n   * @override\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n    );\n    return new LineString(simplifiedFlatCoordinates, 'XY');\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'LineString';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    return intersectsLineString(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      extent,\n      this.getExtent(),\n    );\n  }\n\n  /**\n   * Set the coordinates of the linestring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   * @override\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n    );\n    this.changed();\n  }\n}\n\nexport default LineString;\n","/**\n * @module ol/geom/GeometryCollection\n */\nimport EventType from '../events/EventType.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {\n  closestSquaredDistanceXY,\n  createOrUpdateEmpty,\n  extend,\n  getCenter,\n} from '../extent.js';\nimport Geometry from './Geometry.js';\n\n/**\n * @classdesc\n * An array of {@link module:ol/geom/Geometry~Geometry} objects.\n *\n * @api\n */\nclass GeometryCollection extends Geometry {\n  /**\n   * @param {Array<Geometry>} geometries Geometries.\n   */\n  constructor(geometries) {\n    super();\n\n    /**\n     * @private\n     * @type {Array<Geometry>}\n     */\n    this.geometries_ = geometries;\n\n    /**\n     * @private\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     */\n    this.changeEventsKeys_ = [];\n\n    this.listenGeometriesChange_();\n  }\n\n  /**\n   * @private\n   */\n  unlistenGeometriesChange_() {\n    this.changeEventsKeys_.forEach(unlistenByKey);\n    this.changeEventsKeys_.length = 0;\n  }\n\n  /**\n   * @private\n   */\n  listenGeometriesChange_() {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      this.changeEventsKeys_.push(\n        listen(geometries[i], EventType.CHANGE, this.changed, this),\n      );\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!GeometryCollection} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const geometryCollection = new GeometryCollection(\n      cloneGeometries(this.geometries_),\n    );\n    geometryCollection.applyProperties(this);\n    return geometryCollection;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      minSquaredDistance = geometries[i].closestPointXY(\n        x,\n        y,\n        closestPoint,\n        minSquaredDistance,\n      );\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   * @override\n   */\n  containsXY(x, y) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].containsXY(x, y)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @override\n   */\n  computeExtent(extent) {\n    createOrUpdateEmpty(extent);\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      extend(extent, geometries[i].getExtent());\n    }\n    return extent;\n  }\n\n  /**\n   * Return the geometries that make up this geometry collection.\n   * @return {Array<Geometry>} Geometries.\n   * @api\n   */\n  getGeometries() {\n    return cloneGeometries(this.geometries_);\n  }\n\n  /**\n   * @return {Array<Geometry>} Geometries.\n   */\n  getGeometriesArray() {\n    return this.geometries_;\n  }\n\n  /**\n   * @return {Array<Geometry>} Geometries.\n   */\n  getGeometriesArrayRecursive() {\n    /** @type {Array<Geometry>} */\n    let geometriesArray = [];\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].getType() === this.getType()) {\n        geometriesArray = geometriesArray.concat(\n          /** @type {GeometryCollection} */ (\n            geometries[i]\n          ).getGeometriesArrayRecursive(),\n        );\n      } else {\n        geometriesArray.push(geometries[i]);\n      }\n    }\n    return geometriesArray;\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {GeometryCollection} Simplified GeometryCollection.\n   * @override\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    if (\n      squaredTolerance < 0 ||\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n        squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)\n    ) {\n      return this;\n    }\n\n    const simplifiedGeometries = [];\n    const geometries = this.geometries_;\n    let simplified = false;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      const geometry = geometries[i];\n      const simplifiedGeometry =\n        geometry.getSimplifiedGeometry(squaredTolerance);\n      simplifiedGeometries.push(simplifiedGeometry);\n      if (simplifiedGeometry !== geometry) {\n        simplified = true;\n      }\n    }\n    if (simplified) {\n      const simplifiedGeometryCollection = new GeometryCollection(\n        simplifiedGeometries,\n      );\n      return simplifiedGeometryCollection;\n    }\n    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n    return this;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'GeometryCollection';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].intersectsExtent(extent)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return this.geometries_.length === 0;\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   * @override\n   */\n  rotate(angle, anchor) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].rotate(angle, anchor);\n    }\n    this.changed();\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   * @override\n   */\n  scale(sx, sy, anchor) {\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].scale(sx, sy, anchor);\n    }\n    this.changed();\n  }\n\n  /**\n   * Set the geometries that make up this geometry collection.\n   * @param {Array<Geometry>} geometries Geometries.\n   * @api\n   */\n  setGeometries(geometries) {\n    this.setGeometriesArray(cloneGeometries(geometries));\n  }\n\n  /**\n   * @param {Array<Geometry>} geometries Geometries.\n   */\n  setGeometriesArray(geometries) {\n    this.unlistenGeometriesChange_();\n    this.geometries_ = geometries;\n    this.listenGeometriesChange_();\n    this.changed();\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   * @api\n   * @override\n   */\n  applyTransform(transformFn) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].applyTransform(transformFn);\n    }\n    this.changed();\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   * @override\n   */\n  translate(deltaX, deltaY) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].translate(deltaX, deltaY);\n    }\n    this.changed();\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    this.unlistenGeometriesChange_();\n    super.disposeInternal();\n  }\n}\n\n/**\n * @param {Array<Geometry>} geometries Geometries.\n * @return {Array<Geometry>} Cloned geometries.\n */\nfunction cloneGeometries(geometries) {\n  return geometries.map((geometry) => geometry.clone());\n}\n\nexport default GeometryCollection;\n","/**\n * @module ol/geom/MultiLineString\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {arrayMaxSquaredDelta, assignClosestArrayPoint} from './flat/closest.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {\n  interpolatePoint,\n  lineStringsCoordinateAtM,\n} from './flat/interpolate.js';\nimport {intersectsLineStringArray} from './flat/intersectsextent.js';\nimport {lineStringLength} from './flat/length.js';\nimport {douglasPeuckerArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nclass MultiLineString extends SimpleGeometry {\n  /**\n   * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\n   *     Coordinates or LineString geometries. (For internal use, flat coordinates in\n   *     combination with `layout` and `ends` are also accepted.)\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<number>} [ends] Flat coordinate ends for internal use.\n   */\n  constructor(coordinates, layout, ends) {\n    super();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (Array.isArray(coordinates[0])) {\n      this.setCoordinates(\n        /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    } else if (layout !== undefined && ends) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n      this.ends_ = ends;\n    } else {\n      const lineStrings = /** @type {Array<LineString>} */ (coordinates);\n      /** @type {Array<number>} */\n      const flatCoordinates = [];\n      const ends = [];\n      for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n        const lineString = lineStrings[i];\n        extend(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n      const layout =\n        lineStrings.length === 0\n          ? this.getLayout()\n          : lineStrings[0].getLayout();\n      this.setFlatCoordinates(layout, flatCoordinates);\n      this.ends_ = ends;\n    }\n  }\n\n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {LineString} lineString LineString.\n   * @api\n   */\n  appendLineString(lineString) {\n    extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiLineString} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const multiLineString = new MultiLineString(\n      this.flatCoordinates.slice(),\n      this.layout,\n      this.ends_.slice(),\n    );\n    multiLineString.applyProperties(this);\n    return multiLineString;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        arrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.ends_,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      this.maxDelta_,\n      false,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\n   * @param {boolean} [interpolate] Interpolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n   * @api\n   */\n  getCoordinateAtM(m, extrapolate, interpolate) {\n    if (\n      (this.layout != 'XYM' && this.layout != 'XYZM') ||\n      this.flatCoordinates.length === 0\n    ) {\n      return null;\n    }\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\n    interpolate = interpolate !== undefined ? interpolate : false;\n    return lineStringsCoordinateAtM(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      m,\n      extrapolate,\n      interpolate,\n    );\n  }\n\n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   * @override\n   */\n  getCoordinates() {\n    return inflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n    );\n  }\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {LineString} LineString.\n   * @api\n   */\n  getLineString(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LineString(\n      this.flatCoordinates.slice(\n        index === 0 ? 0 : this.ends_[index - 1],\n        this.ends_[index],\n      ),\n      this.layout,\n    );\n  }\n\n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array<LineString>} LineStrings.\n   * @api\n   */\n  getLineStrings() {\n    const flatCoordinates = this.flatCoordinates;\n    const ends = this.ends_;\n    const layout = this.layout;\n    /** @type {Array<LineString>} */\n    const lineStrings = [];\n    let offset = 0;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const lineString = new LineString(\n        flatCoordinates.slice(offset, end),\n        layout,\n      );\n      lineStrings.push(lineString);\n      offset = end;\n    }\n    return lineStrings;\n  }\n\n  /**\n   * Return the sum of all line string lengths\n   * @return {number} Length (on projected plane).\n   * @api\n   */\n  getLength() {\n    const ends = this.ends_;\n    let start = 0;\n    let length = 0;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      length += lineStringLength(\n        this.flatCoordinates,\n        start,\n        ends[i],\n        this.stride,\n      );\n      start = ends[i];\n    }\n    return length;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  getFlatMidpoints() {\n    /** @type {Array<number>} */\n    const midpoints = [];\n    const flatCoordinates = this.flatCoordinates;\n    let offset = 0;\n    const ends = this.ends_;\n    const stride = this.stride;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const midpoint = interpolatePoint(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        0.5,\n      );\n      extend(midpoints, midpoint);\n      offset = end;\n    }\n    return midpoints;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiLineString} Simplified MultiLineString.\n   * @protected\n   * @override\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEnds,\n    );\n    return new MultiLineString(simplifiedFlatCoordinates, 'XY', simplifiedEnds);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'MultiLineString';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    return intersectsLineStringArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      extent,\n    );\n  }\n\n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   * @override\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const ends = deflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.ends_,\n    );\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n}\n\nexport default MultiLineString;\n","/**\n * @module ol/geom/MultiPoint\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY, containsXY} from '../extent.js';\nimport {squaredDistance as squaredDx} from '../math.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {inflateCoordinates} from './flat/inflate.js';\n\n/**\n * @classdesc\n * Multi-point geometry.\n *\n * @api\n */\nclass MultiPoint extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n    if (layout && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n    } else {\n      this.setCoordinates(\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    }\n  }\n\n  /**\n   * Append the passed point to this multipoint.\n   * @param {Point} point Point.\n   * @api\n   */\n  appendPoint(point) {\n    extend(this.flatCoordinates, point.getFlatCoordinates());\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPoint} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const multiPoint = new MultiPoint(\n      this.flatCoordinates.slice(),\n      this.layout,\n    );\n    multiPoint.applyProperties(this);\n    return multiPoint;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    const flatCoordinates = this.flatCoordinates;\n    const stride = this.stride;\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      const squaredDistance = squaredDx(\n        x,\n        y,\n        flatCoordinates[i],\n        flatCoordinates[i + 1],\n      );\n      if (squaredDistance < minSquaredDistance) {\n        minSquaredDistance = squaredDistance;\n        for (let j = 0; j < stride; ++j) {\n          closestPoint[j] = flatCoordinates[i + j];\n        }\n        closestPoint.length = stride;\n      }\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * Return the coordinates of the multipoint.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   * @override\n   */\n  getCoordinates() {\n    return inflateCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * Return the point at the specified index.\n   * @param {number} index Index.\n   * @return {Point} Point.\n   * @api\n   */\n  getPoint(index) {\n    const n = this.flatCoordinates.length / this.stride;\n    if (index < 0 || n <= index) {\n      return null;\n    }\n    return new Point(\n      this.flatCoordinates.slice(\n        index * this.stride,\n        (index + 1) * this.stride,\n      ),\n      this.layout,\n    );\n  }\n\n  /**\n   * Return the points of this multipoint.\n   * @return {Array<Point>} Points.\n   * @api\n   */\n  getPoints() {\n    const flatCoordinates = this.flatCoordinates;\n    const layout = this.layout;\n    const stride = this.stride;\n    /** @type {Array<Point>} */\n    const points = [];\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      const point = new Point(flatCoordinates.slice(i, i + stride), layout);\n      points.push(point);\n    }\n    return points;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'MultiPoint';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const stride = this.stride;\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      const x = flatCoordinates[i];\n      const y = flatCoordinates[i + 1];\n      if (containsXY(extent, x, y)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Set the coordinates of the multipoint.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   * @override\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n    );\n    this.changed();\n  }\n}\n\nexport default MultiPoint;\n","/**\n * @module ol/geom/MultiPolygon\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {linearRingss as linearRingssArea} from './flat/area.js';\nimport {linearRingss as linearRingssCenter} from './flat/center.js';\nimport {\n  assignClosestMultiArrayPoint,\n  multiArrayMaxSquaredDelta,\n} from './flat/closest.js';\nimport {linearRingssContainsXY} from './flat/contains.js';\nimport {deflateMultiCoordinatesArray} from './flat/deflate.js';\nimport {inflateMultiCoordinatesArray} from './flat/inflate.js';\nimport {getInteriorPointsOfMultiArray} from './flat/interiorpoint.js';\nimport {intersectsLinearRingMultiArray} from './flat/intersectsextent.js';\nimport {\n  linearRingssAreOriented,\n  orientLinearRingsArray,\n} from './flat/orient.js';\nimport {quantizeMultiArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nclass MultiPolygon extends SimpleGeometry {\n  /**\n   * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.\n   */\n  constructor(coordinates, layout, endss) {\n    super();\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.endss_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointsRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (!endss && !Array.isArray(coordinates[0])) {\n      const polygons = /** @type {Array<Polygon>} */ (coordinates);\n      /** @type {Array<number>} */\n      const flatCoordinates = [];\n      const thisEndss = [];\n      for (let i = 0, ii = polygons.length; i < ii; ++i) {\n        const polygon = polygons[i];\n        const offset = flatCoordinates.length;\n        const ends = polygon.getEnds();\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        thisEndss.push(ends);\n      }\n      layout =\n        polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();\n      coordinates = flatCoordinates;\n      endss = thisEndss;\n    }\n    if (layout !== undefined && endss) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n      this.endss_ = endss;\n    } else {\n      this.setCoordinates(\n        /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    }\n  }\n\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  appendPolygon(polygon) {\n    /** @type {Array<number>} */\n    let ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      const offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @api\n   * @override\n   */\n  clone() {\n    const len = this.endss_.length;\n    const newEndss = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n\n    const multiPolygon = new MultiPolygon(\n      this.flatCoordinates.slice(),\n      this.layout,\n      newEndss,\n    );\n    multiPolygon.applyProperties(this);\n\n    return multiPolygon;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   * @override\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        multiArrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.endss_,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   * @override\n   */\n  containsXY(x, y) {\n    return linearRingssContainsXY(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      x,\n      y,\n    );\n  }\n\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingssArea(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n    );\n  }\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean} [right] Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @api\n   * @override\n   */\n  getCoordinates(right) {\n    let flatCoordinates;\n    if (right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(\n        flatCoordinates,\n        0,\n        this.endss_,\n        this.stride,\n        right,\n      );\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateMultiCoordinatesArray(\n      flatCoordinates,\n      0,\n      this.endss_,\n      this.stride,\n    );\n  }\n\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n  getEndss() {\n    return this.endss_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      const flatCenters = linearRingssCenter(\n        this.flatCoordinates,\n        0,\n        this.endss_,\n        this.stride,\n      );\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.getOrientedFlatCoordinates(),\n        0,\n        this.endss_,\n        this.stride,\n        flatCenters,\n      );\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.flatInteriorPoints_);\n  }\n\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  getInteriorPoints() {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), 'XYM');\n  }\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      const flatCoordinates = this.flatCoordinates;\n      if (\n        linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)\n      ) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRingsArray(\n          this.orientedFlatCoordinates_,\n          0,\n          this.endss_,\n          this.stride,\n        );\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.orientedFlatCoordinates_);\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiPolygon} Simplified MultiPolygon.\n   * @protected\n   * @override\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    /** @type {Array<Array<number>>} */\n    const simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(\n      this.flatCoordinates,\n      0,\n      this.endss_,\n      this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEndss,\n    );\n    return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);\n  }\n\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n  getPolygon(index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    let offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      const prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    const ends = this.endss_[index].slice();\n    const end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(\n      this.flatCoordinates.slice(offset, end),\n      this.layout,\n      ends,\n    );\n  }\n\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n  getPolygons() {\n    const layout = this.layout;\n    const flatCoordinates = this.flatCoordinates;\n    const endss = this.endss_;\n    const polygons = [];\n    let offset = 0;\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      const ends = endss[i].slice();\n      const end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      const polygon = new Polygon(\n        flatCoordinates.slice(offset, end),\n        layout,\n        ends,\n      );\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   * @override\n   */\n  getType() {\n    return 'MultiPolygon';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   * @override\n   */\n  intersectsExtent(extent) {\n    return intersectsLinearRingMultiArray(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      extent,\n    );\n  }\n\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   * @override\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const endss = deflateMultiCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.endss_,\n    );\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      const lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length =\n        lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  }\n}\n\nexport default MultiPolygon;\n","/**\n * @module ol/format/Feature\n */\nimport Feature from '../Feature.js';\nimport {\n  linearRingsAreOriented,\n  linearRingssAreOriented,\n  orientLinearRings,\n  orientLinearRingsArray,\n} from '../geom/flat/orient.js';\nimport {\n  GeometryCollection,\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from '../geom.js';\nimport {\n  equivalent as equivalentProjection,\n  get as getProjection,\n  getTransform,\n  transformExtent,\n} from '../proj.js';\nimport RenderFeature from '../render/Feature.js';\nimport {abstract} from '../util.js';\n\n/**\n * @typedef {Object} ReadOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are reading.\n * If not provided, the projection will be derived from the data (where possible) or\n * the `dataProjection` of the format is assigned (where set). If the projection\n * can not be derived from the data and if no `dataProjection` is set for a format,\n * the features will not be reprojected.\n * @property {import(\"../extent.js\").Extent} [extent] Tile extent in map units of the tile being read.\n * This is only required when reading data with tile pixels as geometry units. When configured,\n * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be\n * provided.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * created by the format reader. If not provided, features will be returned in the\n * `dataProjection`.\n */\n\n/**\n * @typedef {Object} WriteOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are writing.\n * If not provided, the `dataProjection` of the format is assigned (where set).\n * If no `dataProjection` is set for a format, the features will be returned\n * in the `featureProjection`.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * that will be serialized by the format writer. If not provided, geometries are assumed\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\n * as they are provided at construction.  If `true`, the right-hand rule will\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\n * exterior and counter-clockwise for interior rings).  Note that not all\n * formats support this.  The GeoJSON format does use this property when writing\n * geometries.\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\n * coordinates with a large number of decimal places, not generally wanted on output.\n * Set a number here to round coordinates. Can also be used to ensure that\n * coordinates read in can be written back out with the same number of decimals.\n * Default is no rounding.\n */\n\n/**\n * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type\n */\n\n/**\n * @typedef {Object} SimpleGeometryObject\n * @property {import('../geom/Geometry.js').Type} type Type.\n * @property {Array<number>} flatCoordinates Flat coordinates.\n * @property {Array<number>|Array<Array<number>>} [ends] Ends or endss.\n * @property {import('../geom/Geometry.js').GeometryLayout} [layout] Layout.\n */\n\n/**\n * @typedef {Array<GeometryObject>} GeometryCollectionObject\n */\n\n/**\n * @typedef {SimpleGeometryObject|GeometryCollectionObject} GeometryObject\n */\n\n/**\n * @typedef {Object} FeatureObject\n * @property {string|number} [id] Id.\n * @property {GeometryObject} [geometry] Geometry.\n * @property {Object<string, *>} [properties] Properties.\n */\n\n/***\n * @template {import('../Feature.js').FeatureLike} T\n * @typedef {T extends RenderFeature ? typeof RenderFeature : typeof Feature} FeatureToFeatureClass\n */\n\n/***\n * @template {import(\"../Feature.js\").FeatureClass} T\n * @typedef {T[keyof T] extends RenderFeature ? RenderFeature : Feature} FeatureClassToFeature\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @template {import('../Feature.js').FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @abstract\n * @api\n */\nclass FeatureFormat {\n  constructor() {\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.dataProjection = undefined;\n\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.defaultFeatureProjection = undefined;\n\n    /**\n     * @protected\n     * @type {FeatureToFeatureClass<FeatureType>}\n     */\n    this.featureClass = /** @type {FeatureToFeatureClass<FeatureType>} */ (\n      Feature\n    );\n\n    /**\n     * A list media types supported by the format in descending order of preference.\n     * @type {Array<string>}\n     */\n    this.supportedMediaTypes = null;\n  }\n\n  /**\n   * Adds the data projection to the read options.\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Options.\n   * @return {ReadOptions|undefined} Options.\n   * @protected\n   */\n  getReadOptions(source, options) {\n    if (options) {\n      let dataProjection = options.dataProjection\n        ? getProjection(options.dataProjection)\n        : this.readProjection(source);\n      if (\n        options.extent &&\n        dataProjection &&\n        dataProjection.getUnits() === 'tile-pixels'\n      ) {\n        dataProjection = getProjection(dataProjection);\n        dataProjection.setWorldExtent(options.extent);\n      }\n      options = {\n        dataProjection: dataProjection,\n        featureProjection: options.featureProjection,\n      };\n    }\n    return this.adaptOptions(options);\n  }\n\n  /**\n   * Sets the `dataProjection` on the options, if no `dataProjection`\n   * is set.\n   * @param {WriteOptions|ReadOptions|undefined} options\n   *     Options.\n   * @protected\n   * @return {WriteOptions|ReadOptions|undefined}\n   *     Updated options.\n   */\n  adaptOptions(options) {\n    return Object.assign(\n      {\n        dataProjection: this.dataProjection,\n        featureProjection: this.defaultFeatureProjection,\n        featureClass: this.featureClass,\n      },\n      options,\n    );\n  }\n\n  /**\n   * @abstract\n   * @return {Type} The format type.\n   */\n  getType() {\n    return abstract();\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {FeatureType|Array<FeatureType>} Feature.\n   */\n  readFeature(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @abstract\n   * @param {Document|Element|ArrayBuffer|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {Array<FeatureType>} Features.\n   */\n  readFeatures(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometry(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   */\n  readProjection(source) {\n    return abstract();\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @abstract\n   * @param {Feature} feature Feature.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeature(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @abstract\n   * @param {Array<Feature>} features Features.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeatures(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeGeometry(geometry, options) {\n    return abstract();\n  }\n}\n\nexport default FeatureFormat;\n\n/**\n * @template {import(\"../geom/Geometry.js\").default|RenderFeature} T\n * @param {T} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {T} Transformed geometry.\n */\nexport function transformGeometryWithOptions(geometry, write, options) {\n  const featureProjection = options\n    ? getProjection(options.featureProjection)\n    : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n\n  let transformed = geometry;\n  if (\n    featureProjection &&\n    dataProjection &&\n    !equivalentProjection(featureProjection, dataProjection)\n  ) {\n    if (write) {\n      transformed = /** @type {T} */ (geometry.clone());\n    }\n    const fromProjection = write ? featureProjection : dataProjection;\n    const toProjection = write ? dataProjection : featureProjection;\n    if (fromProjection.getUnits() === 'tile-pixels') {\n      transformed.transform(fromProjection, toProjection);\n    } else {\n      transformed.applyTransform(getTransform(fromProjection, toProjection));\n    }\n  }\n  if (\n    write &&\n    options &&\n    /** @type {WriteOptions} */ (options).decimals !== undefined\n  ) {\n    const power = Math.pow(10, /** @type {WriteOptions} */ (options).decimals);\n    // if decimals option on write, round each coordinate appropriately\n    /**\n     * @param {Array<number>} coordinates Coordinates.\n     * @return {Array<number>} Transformed coordinates.\n     */\n    const transform = function (coordinates) {\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\n      }\n      return coordinates;\n    };\n    if (transformed === geometry) {\n      transformed = /** @type {T} */ (geometry.clone());\n    }\n    transformed.applyTransform(transform);\n  }\n  return transformed;\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {ReadOptions} [options] Read options.\n * @return {import(\"../extent.js\").Extent} Transformed extent.\n */\nexport function transformExtentWithOptions(extent, options) {\n  const featureProjection = options\n    ? getProjection(options.featureProjection)\n    : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n\n  if (\n    featureProjection &&\n    dataProjection &&\n    !equivalentProjection(featureProjection, dataProjection)\n  ) {\n    return transformExtent(extent, dataProjection, featureProjection);\n  }\n  return extent;\n}\n\nconst GeometryConstructor = {\n  Point: Point,\n  LineString: LineString,\n  Polygon: Polygon,\n  MultiPoint: MultiPoint,\n  MultiLineString: MultiLineString,\n  MultiPolygon: MultiPolygon,\n};\n\nfunction orientFlatCoordinates(flatCoordinates, ends, stride) {\n  if (Array.isArray(ends[0])) {\n    // MultiPolagon\n    if (!linearRingssAreOriented(flatCoordinates, 0, ends, stride)) {\n      flatCoordinates = flatCoordinates.slice();\n      orientLinearRingsArray(flatCoordinates, 0, ends, stride);\n    }\n    return flatCoordinates;\n  }\n  if (!linearRingsAreOriented(flatCoordinates, 0, ends, stride)) {\n    flatCoordinates = flatCoordinates.slice();\n    orientLinearRings(flatCoordinates, 0, ends, stride);\n  }\n  return flatCoordinates;\n}\n\n/**\n * @param {FeatureObject} object Feature object.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {RenderFeature|Array<RenderFeature>} Render feature.\n */\nexport function createRenderFeature(object, options) {\n  const geometry = object.geometry;\n  if (!geometry) {\n    return [];\n  }\n  if (Array.isArray(geometry)) {\n    return geometry\n      .map((geometry) => createRenderFeature({...object, geometry}))\n      .flat();\n  }\n\n  const geometryType =\n    geometry.type === 'MultiPolygon' ? 'Polygon' : geometry.type;\n  if (geometryType === 'GeometryCollection' || geometryType === 'Circle') {\n    throw new Error('Unsupported geometry type: ' + geometryType);\n  }\n\n  const stride = geometry.layout.length;\n  return transformGeometryWithOptions(\n    new RenderFeature(\n      geometryType,\n      geometryType === 'Polygon'\n        ? orientFlatCoordinates(geometry.flatCoordinates, geometry.ends, stride)\n        : geometry.flatCoordinates,\n      geometry.ends?.flat(),\n      stride,\n      object.properties || {},\n      object.id,\n    ).enableSimplifyTransformed(),\n    false,\n    options,\n  );\n}\n\n/**\n * @param {GeometryObject|null} object Geometry object.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nexport function createGeometry(object, options) {\n  if (!object) {\n    return null;\n  }\n  if (Array.isArray(object)) {\n    const geometries = object.map((geometry) =>\n      createGeometry(geometry, options),\n    );\n    return new GeometryCollection(geometries);\n  }\n  const Geometry = GeometryConstructor[object.type];\n  return transformGeometryWithOptions(\n    new Geometry(object.flatCoordinates, object.layout || 'XY', object.ends),\n    false,\n    options,\n  );\n}\n","/**\n * @module ol/format/JSONFeature\n */\nimport {abstract} from '../util.js';\nimport FeatureFormat from './Feature.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for JSON feature formats.\n *\n * @template {import('../Feature.js').FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @extends {FeatureFormat<FeatureType>}\n * @abstract\n */\nclass JSONFeature extends FeatureFormat {\n  constructor() {\n    super();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   * @override\n   */\n  getType() {\n    return 'json';\n  }\n\n  /**\n   * Read a feature.  Only works for a single feature. Use `readFeatures` to\n   * read a feature collection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {FeatureType|Array<FeatureType>} Feature.\n   * @api\n   * @override\n   */\n  readFeature(source, options) {\n    return this.readFeatureFromObject(\n      getObject(source),\n      this.getReadOptions(source, options),\n    );\n  }\n\n  /**\n   * Read all features.  Works with both a single feature and a feature\n   * collection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   * @override\n   */\n  readFeatures(source, options) {\n    return this.readFeaturesFromObject(\n      getObject(source),\n      this.getReadOptions(source, options),\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {FeatureType|Array<FeatureType>} Feature.\n   */\n  readFeatureFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<FeatureType>} Features.\n   */\n  readFeaturesFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a geometry.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   * @override\n   */\n  readGeometry(source, options) {\n    return this.readGeometryFromObject(\n      getObject(source),\n      this.getReadOptions(source, options),\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   * @override\n   */\n  readProjection(source) {\n    return this.readProjectionFromObject(getObject(source));\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromObject(object) {\n    return abstract();\n  }\n\n  /**\n   * Encode a feature as string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   * @api\n   * @override\n   */\n  writeFeature(feature, options) {\n    return JSON.stringify(this.writeFeatureObject(feature, options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeFeatureObject(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded features.\n   * @api\n   * @override\n   */\n  writeFeatures(features, options) {\n    return JSON.stringify(this.writeFeaturesObject(features, options));\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeFeaturesObject(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode a geometry as string.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded geometry.\n   * @api\n   * @override\n   */\n  writeGeometry(geometry, options) {\n    return JSON.stringify(this.writeGeometryObject(geometry, options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeGeometryObject(geometry, options) {\n    return abstract();\n  }\n}\n\n/**\n * @param {Document|Element|Object|string} source Source.\n * @return {Object} Object.\n */\nfunction getObject(source) {\n  if (typeof source === 'string') {\n    const object = JSON.parse(source);\n    return object ? /** @type {Object} */ (object) : null;\n  }\n  if (source !== null) {\n    return source;\n  }\n  return null;\n}\n\nexport default JSONFeature;\n","/**\n * @module ol/format/GeoJSON\n */\n\nimport Feature from '../Feature.js';\nimport {getLayoutForStride} from '../geom/SimpleGeometry.js';\nimport {\n  deflateCoordinatesArray,\n  deflateMultiCoordinatesArray,\n} from '../geom/flat/deflate.js';\nimport {isEmpty} from '../obj.js';\nimport {get as getProjection} from '../proj.js';\nimport RenderFeature from '../render/Feature.js';\nimport {\n  createGeometry,\n  createRenderFeature,\n  transformGeometryWithOptions,\n} from './Feature.js';\nimport JSONFeature from './JSONFeature.js';\n\n/**\n * @typedef {import(\"geojson\").GeoJSON} GeoJSONObject\n * @typedef {import(\"geojson\").Feature} GeoJSONFeature\n * @typedef {import(\"geojson\").FeatureCollection} GeoJSONFeatureCollection\n * @typedef {import(\"geojson\").Geometry} GeoJSONGeometry\n * @typedef {import(\"geojson\").Point} GeoJSONPoint\n * @typedef {import(\"geojson\").LineString} GeoJSONLineString\n * @typedef {import(\"geojson\").Polygon} GeoJSONPolygon\n * @typedef {import(\"geojson\").MultiPoint} GeoJSONMultiPoint\n * @typedef {import(\"geojson\").MultiLineString} GeoJSONMultiLineString\n * @typedef {import(\"geojson\").MultiPolygon} GeoJSONMultiPolygon\n * @typedef {import(\"geojson\").GeometryCollection} GeoJSONGeometryCollection\n */\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @typedef {Object} Options\n *\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection for features read or\n * written by the format.  Options passed to read or write methods will take precedence.\n * @property {string} [geometryName] Geometry name to use when creating features.\n * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include\n * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader\n * will look for that field to set the geometry name. If both this field is set to `true`\n * and a `geometryName` is provided, the `geometryName` will take precedence.\n * @property {import('./Feature.js').FeatureToFeatureClass<FeatureType>} [featureClass] Feature class\n * to be used when reading features. The default is {@link module:ol/Feature~Feature}. If performance is\n * the primary concern, and features are not going to be modified or round-tripped through the format,\n * consider using {@link module:ol/render/Feature~RenderFeature}\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GeoJSON format.\n *\n * @template {import('../Feature.js').FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @extends {JSONFeature<FeatureType>}\n * @api\n */\nclass GeoJSON extends JSONFeature {\n  /**\n   * @param {Options<FeatureType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super();\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection(\n      options.dataProjection ? options.dataProjection : 'EPSG:4326',\n    );\n\n    if (options.featureProjection) {\n      /**\n       * @type {import(\"../proj/Projection.js\").default}\n       */\n      this.defaultFeatureProjection = getProjection(options.featureProjection);\n    }\n\n    if (options.featureClass) {\n      this.featureClass = options.featureClass;\n    }\n\n    /**\n     * Name of the geometry attribute for features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * Look for the `geometry_name` in the feature GeoJSON\n     * @type {boolean|undefined}\n     * @private\n     */\n    this.extractGeometryName_ = options.extractGeometryName;\n\n    this.supportedMediaTypes = [\n      'application/geo+json',\n      'application/vnd.geo+json',\n    ];\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {FeatureType|Array<FeatureType>} Feature.\n   * @override\n   */\n  readFeatureFromObject(object, options) {\n    /**\n     * @type {GeoJSONFeature}\n     */\n    let geoJSONFeature = null;\n    if (object['type'] === 'Feature') {\n      geoJSONFeature = /** @type {GeoJSONFeature} */ (object);\n    } else {\n      geoJSONFeature = {\n        'type': 'Feature',\n        'geometry': /** @type {GeoJSONGeometry} */ (object),\n        'properties': null,\n      };\n    }\n\n    const geometry = readGeometryInternal(geoJSONFeature['geometry'], options);\n    if (this.featureClass === RenderFeature) {\n      return /** @type {FeatureType|Array<FeatureType>} */ (\n        createRenderFeature(\n          {\n            geometry,\n            id: geoJSONFeature['id'],\n            properties: geoJSONFeature['properties'],\n          },\n          options,\n        )\n      );\n    }\n\n    const feature = new Feature();\n    if (this.geometryName_) {\n      feature.setGeometryName(this.geometryName_);\n    } else if (this.extractGeometryName_ && geoJSONFeature['geometry_name']) {\n      feature.setGeometryName(geoJSONFeature['geometry_name']);\n    }\n    feature.setGeometry(createGeometry(geometry, options));\n\n    if ('id' in geoJSONFeature) {\n      feature.setId(geoJSONFeature['id']);\n    }\n\n    if (geoJSONFeature['properties']) {\n      feature.setProperties(geoJSONFeature['properties'], true);\n    }\n    return /** @type {FeatureType|Array<FeatureType>} */ (feature);\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<FeatureType>} Features.\n   * @override\n   */\n  readFeaturesFromObject(object, options) {\n    const geoJSONObject = /** @type {GeoJSONObject} */ (object);\n    let features = null;\n    if (geoJSONObject['type'] === 'FeatureCollection') {\n      const geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ (\n        object\n      );\n      features = [];\n      const geoJSONFeatures = geoJSONFeatureCollection['features'];\n      for (let i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {\n        const featureObject = this.readFeatureFromObject(\n          geoJSONFeatures[i],\n          options,\n        );\n        if (!featureObject) {\n          continue;\n        }\n        features.push(featureObject);\n      }\n    } else {\n      features = [this.readFeatureFromObject(object, options)];\n    }\n    return /** @type {Array<FeatureType>} */ (features.flat());\n  }\n\n  /**\n   * @param {GeoJSONGeometry} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @override\n   */\n  readGeometryFromObject(object, options) {\n    return readGeometry(object, options);\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @override\n   */\n  readProjectionFromObject(object) {\n    const crs = object['crs'];\n    let projection;\n    if (crs) {\n      if (crs['type'] == 'name') {\n        projection = getProjection(crs['properties']['name']);\n      } else if (crs['type'] === 'EPSG') {\n        projection = getProjection('EPSG:' + crs['properties']['code']);\n      } else {\n        throw new Error('Unknown SRS type');\n      }\n    } else {\n      projection = this.dataProjection;\n    }\n    return /** @type {import(\"../proj/Projection.js\").default} */ (projection);\n  }\n\n  /**\n   * Encode a feature as a GeoJSON Feature object.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONFeature} Object.\n   * @api\n   * @override\n   */\n  writeFeatureObject(feature, options) {\n    options = this.adaptOptions(options);\n\n    /** @type {GeoJSONFeature} */\n    const object = {\n      'type': 'Feature',\n      geometry: null,\n      properties: null,\n    };\n\n    const id = feature.getId();\n    if (id !== undefined) {\n      object.id = id;\n    }\n\n    if (!feature.hasProperties()) {\n      return object;\n    }\n\n    const properties = feature.getProperties();\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      object.geometry = writeGeometry(geometry, options);\n\n      delete properties[feature.getGeometryName()];\n    }\n\n    if (!isEmpty(properties)) {\n      object.properties = properties;\n    }\n\n    return object;\n  }\n\n  /**\n   * Encode an array of features as a GeoJSON object.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONFeatureCollection} GeoJSON Object.\n   * @api\n   * @override\n   */\n  writeFeaturesObject(features, options) {\n    options = this.adaptOptions(options);\n    const objects = [];\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      objects.push(this.writeFeatureObject(features[i], options));\n    }\n    return {\n      type: 'FeatureCollection',\n      features: objects,\n    };\n  }\n\n  /**\n   * Encode a geometry as a GeoJSON object.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.\n   * @api\n   * @override\n   */\n  writeGeometryObject(geometry, options) {\n    return writeGeometry(geometry, this.adaptOptions(options));\n  }\n}\n\n/**\n * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"./Feature.js\").GeometryObject} Geometry.\n */\nfunction readGeometryInternal(object, options) {\n  if (!object) {\n    return null;\n  }\n\n  /** @type {import(\"./Feature.js\").GeometryObject} */\n  let geometry;\n  switch (object['type']) {\n    case 'Point': {\n      geometry = readPointGeometry(/** @type {GeoJSONPoint} */ (object));\n      break;\n    }\n    case 'LineString': {\n      geometry = readLineStringGeometry(\n        /** @type {GeoJSONLineString} */ (object),\n      );\n      break;\n    }\n    case 'Polygon': {\n      geometry = readPolygonGeometry(/** @type {GeoJSONPolygon} */ (object));\n      break;\n    }\n    case 'MultiPoint': {\n      geometry = readMultiPointGeometry(\n        /** @type {GeoJSONMultiPoint} */ (object),\n      );\n      break;\n    }\n    case 'MultiLineString': {\n      geometry = readMultiLineStringGeometry(\n        /** @type {GeoJSONMultiLineString} */ (object),\n      );\n      break;\n    }\n    case 'MultiPolygon': {\n      geometry = readMultiPolygonGeometry(\n        /** @type {GeoJSONMultiPolygon} */ (object),\n      );\n      break;\n    }\n    case 'GeometryCollection': {\n      geometry = readGeometryCollectionGeometry(\n        /** @type {GeoJSONGeometryCollection} */ (object),\n      );\n      break;\n    }\n    default: {\n      throw new Error('Unsupported GeoJSON type: ' + object['type']);\n    }\n  }\n  return geometry;\n}\n\n/**\n * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nfunction readGeometry(object, options) {\n  const geometryObject = readGeometryInternal(object, options);\n  return createGeometry(geometryObject, options);\n}\n\n/**\n * @param {GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"./Feature.js\").GeometryCollectionObject} Geometry collection.\n */\nfunction readGeometryCollectionGeometry(object, options) {\n  const geometries = object['geometries'].map(\n    /**\n     * @param {GeoJSONGeometry} geometry Geometry.\n     * @return {import(\"./Feature.js\").GeometryObject} geometry Geometry.\n     */\n    function (geometry) {\n      return readGeometryInternal(geometry, options);\n    },\n  );\n  return geometries;\n}\n\n/**\n * @param {GeoJSONPoint} object Input object.\n * @return {import(\"./Feature.js\").GeometryObject} Point geometry.\n */\nfunction readPointGeometry(object) {\n  const flatCoordinates = object['coordinates'];\n  return {\n    type: 'Point',\n    flatCoordinates,\n    layout: getLayoutForStride(flatCoordinates.length),\n  };\n}\n\n/**\n * @param {GeoJSONLineString} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} LineString geometry.\n */\nfunction readLineStringGeometry(object) {\n  const coordinates = object['coordinates'];\n  const flatCoordinates = coordinates.flat();\n  return {\n    type: 'LineString',\n    flatCoordinates,\n    ends: [flatCoordinates.length],\n    layout: getLayoutForStride(coordinates[0]?.length || 2),\n  };\n}\n\n/**\n * @param {GeoJSONMultiLineString} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} MultiLineString geometry.\n */\nfunction readMultiLineStringGeometry(object) {\n  const coordinates = object['coordinates'];\n  const stride = coordinates[0]?.[0]?.length || 2;\n  const flatCoordinates = [];\n  const ends = deflateCoordinatesArray(flatCoordinates, 0, coordinates, stride);\n  return {\n    type: 'MultiLineString',\n    flatCoordinates,\n    ends,\n    layout: getLayoutForStride(stride),\n  };\n}\n\n/**\n * @param {GeoJSONMultiPoint} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} MultiPoint geometry.\n */\nfunction readMultiPointGeometry(object) {\n  const coordinates = object['coordinates'];\n  return {\n    type: 'MultiPoint',\n    flatCoordinates: coordinates.flat(),\n    layout: getLayoutForStride(coordinates[0]?.length || 2),\n  };\n}\n\n/**\n * @param {GeoJSONMultiPolygon} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} MultiPolygon geometry.\n */\nfunction readMultiPolygonGeometry(object) {\n  const coordinates = object['coordinates'];\n  const flatCoordinates = [];\n  const stride = coordinates[0]?.[0]?.[0].length || 2;\n  const endss = deflateMultiCoordinatesArray(\n    flatCoordinates,\n    0,\n    coordinates,\n    stride,\n  );\n  return {\n    type: 'MultiPolygon',\n    flatCoordinates,\n    ends: endss,\n    layout: getLayoutForStride(stride),\n  };\n}\n\n/**\n * @param {GeoJSONPolygon} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} Polygon.\n */\nfunction readPolygonGeometry(object) {\n  const coordinates = object['coordinates'];\n  const flatCoordinates = [];\n  const stride = coordinates[0]?.[0]?.length;\n  const ends = deflateCoordinatesArray(flatCoordinates, 0, coordinates, stride);\n  return {\n    type: 'Polygon',\n    flatCoordinates,\n    ends,\n    layout: getLayoutForStride(stride),\n  };\n}\n\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeGeometry(geometry, options) {\n  geometry = transformGeometryWithOptions(geometry, true, options);\n\n  const type = geometry.getType();\n\n  /** @type {GeoJSONGeometry} */\n  let geoJSON;\n  switch (type) {\n    case 'Point': {\n      geoJSON = writePointGeometry(\n        /** @type {import(\"../geom/Point.js\").default} */ (geometry),\n        options,\n      );\n      break;\n    }\n    case 'LineString': {\n      geoJSON = writeLineStringGeometry(\n        /** @type {import(\"../geom/LineString.js\").default} */ (geometry),\n        options,\n      );\n      break;\n    }\n    case 'Polygon': {\n      geoJSON = writePolygonGeometry(\n        /** @type {import(\"../geom/Polygon.js\").default} */ (geometry),\n        options,\n      );\n      break;\n    }\n    case 'MultiPoint': {\n      geoJSON = writeMultiPointGeometry(\n        /** @type {import(\"../geom/MultiPoint.js\").default} */ (geometry),\n        options,\n      );\n      break;\n    }\n    case 'MultiLineString': {\n      geoJSON = writeMultiLineStringGeometry(\n        /** @type {import(\"../geom/MultiLineString.js\").default} */ (geometry),\n        options,\n      );\n      break;\n    }\n    case 'MultiPolygon': {\n      geoJSON = writeMultiPolygonGeometry(\n        /** @type {import(\"../geom/MultiPolygon.js\").default} */ (geometry),\n        options,\n      );\n      break;\n    }\n    case 'GeometryCollection': {\n      geoJSON = writeGeometryCollectionGeometry(\n        /** @type {import(\"../geom/GeometryCollection.js\").default} */ (\n          geometry\n        ),\n        options,\n      );\n      break;\n    }\n    case 'Circle': {\n      geoJSON = {\n        type: 'GeometryCollection',\n        geometries: [],\n      };\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return geoJSON;\n}\n\n/**\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.\n */\nfunction writeGeometryCollectionGeometry(geometry, options) {\n  options = Object.assign({}, options);\n  delete options.featureProjection;\n  const geometries = geometry.getGeometriesArray().map(function (geometry) {\n    return writeGeometry(geometry, options);\n  });\n  return {\n    type: 'GeometryCollection',\n    geometries: geometries,\n  };\n}\n\n/**\n * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeLineStringGeometry(geometry, options) {\n  return {\n    type: 'LineString',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiLineStringGeometry(geometry, options) {\n  return {\n    type: 'MultiLineString',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiPointGeometry(geometry, options) {\n  return {\n    type: 'MultiPoint',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiPolygonGeometry(geometry, options) {\n  let right;\n  if (options) {\n    right = options.rightHanded;\n  }\n  return {\n    type: 'MultiPolygon',\n    coordinates: geometry.getCoordinates(right),\n  };\n}\n\n/**\n * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writePointGeometry(geometry, options) {\n  return {\n    type: 'Point',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writePolygonGeometry(geometry, options) {\n  let right;\n  if (options) {\n    right = options.rightHanded;\n  }\n  return {\n    type: 'Polygon',\n    coordinates: geometry.getCoordinates(right),\n  };\n}\n\nexport default GeoJSON;\n"],"names":["LineString","SimpleGeometry","coordinates","layout","coordinate","extend","lineString","x","y","closestPoint","minSquaredDistance","closestSquaredDistanceXY","maxSquaredDelta","assignClosestPoint","callback","forEachSegment","m","extrapolate","lineStringCoordinateAtM","inflateCoordinates","fraction","dest","interpolatePoint","lineStringLength","squaredTolerance","simplifiedFlatCoordinates","douglasPeucker","extent","intersectsLineString","deflateCoordinates","GeometryCollection","Geometry","geometries","unlistenByKey","i","ii","listen","EventType","geometryCollection","cloneGeometries","createOrUpdateEmpty","geometriesArray","simplifiedGeometries","simplified","geometry","simplifiedGeometry","angle","anchor","sx","sy","getCenter","transformFn","deltaX","deltaY","MultiLineString","ends","lineStrings","flatCoordinates","multiLineString","arrayMaxSquaredDelta","assignClosestArrayPoint","interpolate","lineStringsCoordinateAtM","inflateCoordinatesArray","index","offset","end","start","length","midpoints","stride","midpoint","simplifiedEnds","douglasPeuckerArray","intersectsLineStringArray","deflateCoordinatesArray","MultiPoint","point","multiPoint","squaredDistance","squaredDx","j","n","Point","points","containsXY","MultiPolygon","endss","polygons","thisEndss","polygon","jj","len","newEndss","multiPolygon","multiArrayMaxSquaredDelta","assignClosestMultiArrayPoint","linearRingssContainsXY","linearRingssArea","right","orientLinearRingsArray","inflateMultiCoordinatesArray","flatCenters","linearRingssCenter","getInteriorPointsOfMultiArray","linearRingssAreOriented","simplifiedEndss","quantizeMultiArray","prevEnds","Polygon","intersectsLinearRingMultiArray","deflateMultiCoordinatesArray","lastEnds","FeatureFormat","Feature","source","options","dataProjection","getProjection","abstract","feature","features","transformGeometryWithOptions","write","featureProjection","transformed","equivalentProjection","fromProjection","toProjection","getTransform","power","transform","GeometryConstructor","orientFlatCoordinates","linearRingsAreOriented","orientLinearRings","createRenderFeature","object","geometryType","RenderFeature","createGeometry","JSONFeature","getObject","GeoJSON","geoJSONFeature","readGeometryInternal","geoJSONObject","geoJSONFeatureCollection","geoJSONFeatures","featureObject","readGeometry","crs","projection","id","properties","writeGeometry","isEmpty","objects","readPointGeometry","readLineStringGeometry","readPolygonGeometry","readMultiPointGeometry","readMultiLineStringGeometry","readMultiPolygonGeometry","readGeometryCollectionGeometry","geometryObject","getLayoutForStride","type","geoJSON","writePointGeometry","writeLineStringGeometry","writePolygonGeometry","writeMultiPointGeometry","writeMultiLineStringGeometry","writeMultiPolygonGeometry","writeGeometryCollectionGeometry"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}